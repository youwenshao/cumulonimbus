export { getBetterError };
// TO-DO/maybe: make it a library `@brillout/better-error`
// Copies:
// - https://github.com/vikejs/vike/blob/a54b7618d80409c6df4b597489ddbb7739f3e86f/packages/vike/utils/getBetterError.ts
// - https://github.com/vikejs/vike-react/blob/0367843eae1289430413bea69018997c582326c7/packages/vike-react/src/utils/getBetterErrorLight.ts
import { isObject } from './isObject.js';
import { assertIsNotBrowser } from './assertIsNotBrowser.js';
import { objectAssign } from './objectAssign.js';
import { shallowClone } from './shallowClone.js';
assertIsNotBrowser();
function getBetterError(err, modifications) {
    var _a;
    const errOriginal = shallowClone(err);
    let errBetter;
    // Normalize
    if (!isObject(err)) {
        warnMalformed(errOriginal);
        errBetter = new Error(String(err));
    }
    else {
        // We mutate instead of structuredClone(err) to avoid breaking Vite's ssrFixStacktrace() internal rewroteStacktraces.has(err) check
        // https://github.com/vitejs/vite/blob/dafd726032daa98d0e614f97aebe9d4dbffe2ea7/packages/vite/src/node/ssr/ssrStacktrace.ts#L95
        errBetter = err;
    }
    (_a = errBetter.message) !== null && _a !== void 0 ? _a : (errBetter.message = '');
    if (!errBetter.stack) {
        warnMalformed(errOriginal);
        errBetter.stack = new Error(errBetter.message).stack;
    }
    // Modifications: err.hideStack and err.stack
    const { message: modsMessage, ...mods } = modifications;
    Object.assign(errBetter, mods);
    // Modifications: err.message
    if (typeof modsMessage === 'string') {
        // Modify err.message
        const messagePrev = errBetter.message;
        const messageNext = modsMessage;
        errBetter.message = messageNext;
        // Update err.stack
        const messagePrevIdx = errBetter.stack.indexOf(messagePrev);
        if (messagePrevIdx >= 0) {
            // Completely replace the beginning of err.stack — removing prefix such as "SyntaxError: "
            // - Following isn't always true: `err.stack.startsWith(err.message)` — because err.stack can start with "SyntaxError: " whereas err.message doesn't
            const stack = errBetter.stack.slice(messagePrevIdx + messagePrev.length);
            errBetter.stack = messageNext + stack;
        }
        else {
            warnMalformed(errOriginal);
        }
    }
    else {
        if (modsMessage === null || modsMessage === void 0 ? void 0 : modsMessage.append) {
            const messagePrev = errBetter.message;
            const messageNext = errBetter.message + modsMessage.append;
            errBetter.message = messageNext;
            errBetter.stack = errBetter.stack.replace(messagePrev, messageNext);
        }
        if (modsMessage === null || modsMessage === void 0 ? void 0 : modsMessage.prepend) {
            const { prepend } = modsMessage;
            errBetter.message = prepend + errBetter.message;
            errBetter.stack = prepend + errBetter.stack;
        }
    }
    // Enable users to retrieve the original error
    objectAssign(errBetter, { getOriginalError: () => { var _a, _b; return (_b = (_a = errOriginal === null || errOriginal === void 0 ? void 0 : errOriginal.getOriginalError) === null || _a === void 0 ? void 0 : _a.call(errOriginal)) !== null && _b !== void 0 ? _b : errOriginal; } });
    return errBetter;
}
// TO-DO/eventually: think about whether logging this warning is a good idea
function warnMalformed(errOriginal) {
    console.warn('Malformed error: ', errOriginal);
}
