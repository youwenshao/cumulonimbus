import { NextRequest } from 'next/server';
import { getServerSession } from '@/lib/auth';

/**
 * SSE endpoint for streaming generated code during app generation
 * GET /api/scaffolder/code-stream/[conversationId]
 * 
 * Streams code chunks as they are generated by the LLM
 */

// Type definitions for code chunks
export interface CodeChunk {
  id: string;
  component: 'page' | 'form' | 'table' | 'chart' | 'types';
  code: string;
  progress: number;
  timestamp: string;
}

// Global state for SSE management (similar to status endpoint)
const globalCodeEmitters = new Map<string, ReadableStreamDefaultController<Uint8Array>>();
const pendingCodeChunks = new Map<string, CodeChunk[]>();
const connectionTimestamps = new Map<string, number>();
const encoder = new TextEncoder();

// Constants
const HEARTBEAT_INTERVAL = 15000;
const BUFFER_MAX_SIZE = 100;

export async function GET(
  request: NextRequest,
  { params }: { params: { conversationId: string } }
) {
  try {
    const session = await getServerSession();

    if (!session?.user?.id) {
      console.log('üì° Code Stream: Unauthorized request');
      return new Response('Unauthorized', { status: 401 });
    }

    const conversationId = params.conversationId;
    console.log(`üì° Code Stream: Connection request for ${conversationId}`);

    // Create SSE stream
    const stream = new ReadableStream({
      start(controller) {
        // Store controller in global map
        globalCodeEmitters.set(conversationId, controller);
        connectionTimestamps.set(conversationId, Date.now());
        console.log(`üì° Code Stream: Controller registered for ${conversationId}`);
        
        // Send initial connection acknowledgment
        const connectedMsg = {
          id: `connected-${Date.now()}`,
          type: 'connected',
          conversationId,
          timestamp: new Date().toISOString(),
          bufferedCount: pendingCodeChunks.get(conversationId)?.length || 0,
        };
        controller.enqueue(encoder.encode(`data: ${JSON.stringify(connectedMsg)}\n\n`));
        
        // Flush any buffered chunks immediately
        flushBufferedChunks(conversationId);
        
        // Keep connection alive with heartbeat
        const heartbeat = setInterval(() => {
          try {
            if (!globalCodeEmitters.has(conversationId)) {
              clearInterval(heartbeat);
              return;
            }
            controller.enqueue(encoder.encode(`: heartbeat ${Date.now()}\n\n`));
          } catch {
            clearInterval(heartbeat);
            cleanupConnection(conversationId);
          }
        }, HEARTBEAT_INTERVAL);

        // Cleanup on client disconnect
        request.signal.addEventListener('abort', () => {
          console.log(`üì° Code Stream: Client disconnected ${conversationId}`);
          clearInterval(heartbeat);
          cleanupConnection(conversationId);
          try {
            controller.close();
          } catch {
            // Already closed
          }
        });
      },
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache, no-transform',
        'Connection': 'keep-alive',
        'X-Accel-Buffering': 'no',
      },
    });
  } catch (error) {
    console.error('üì° Code Stream: Endpoint error:', error);
    return new Response('Internal Server Error', { status: 500 });
  }
}

/**
 * Cleanup connection state
 */
function cleanupConnection(conversationId: string) {
  globalCodeEmitters.delete(conversationId);
  connectionTimestamps.delete(conversationId);
  // Keep pending chunks briefly for reconnection
  setTimeout(() => {
    if (!globalCodeEmitters.has(conversationId)) {
      pendingCodeChunks.delete(conversationId);
    }
  }, 5000);
}

/**
 * Flush all buffered code chunks for a conversation
 */
function flushBufferedChunks(conversationId: string) {
  const buffer = pendingCodeChunks.get(conversationId);
  const controller = globalCodeEmitters.get(conversationId);
  
  if (!buffer || buffer.length === 0 || !controller) {
    return;
  }
  
  console.log(`üì§ Code Stream: Flushing ${buffer.length} buffered chunks for ${conversationId}`);
  
  for (const chunk of buffer) {
    try {
      const data = `data: ${JSON.stringify(chunk)}\n\n`;
      controller.enqueue(encoder.encode(data));
    } catch (error) {
      console.error(`‚ùå Failed to flush code chunk:`, error);
      break;
    }
  }
  
  pendingCodeChunks.delete(conversationId);
}

/**
 * Buffer a code chunk for later delivery
 */
function bufferChunk(conversationId: string, chunk: CodeChunk) {
  if (!pendingCodeChunks.has(conversationId)) {
    pendingCodeChunks.set(conversationId, []);
  }
  
  const buffer = pendingCodeChunks.get(conversationId)!;
  
  // Enforce max buffer size (FIFO)
  if (buffer.length >= BUFFER_MAX_SIZE) {
    buffer.shift();
  }
  
  buffer.push(chunk);
}

/**
 * Check if a controller is healthy
 */
function isControllerHealthy(conversationId: string): boolean {
  const controller = globalCodeEmitters.get(conversationId);
  return !!controller;
}

/**
 * Emit a code chunk to a conversation's SSE stream
 */
export function emitCodeChunk(
  conversationId: string,
  chunk: Omit<CodeChunk, 'id' | 'timestamp'>
): boolean {
  const codeChunk: CodeChunk = {
    id: `code-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    ...chunk,
    timestamp: new Date().toISOString(),
  };

  // Check if we have a healthy controller
  if (!isControllerHealthy(conversationId)) {
    // Buffer the chunk for later delivery
    bufferChunk(conversationId, codeChunk);
    return false;
  }

  const controller = globalCodeEmitters.get(conversationId)!;

  // First flush any buffered chunks
  flushBufferedChunks(conversationId);

  // Then send the current chunk
  try {
    const data = `data: ${JSON.stringify(codeChunk)}\n\n`;
    controller.enqueue(encoder.encode(data));
    console.log(`üì§ emitCodeChunk [${conversationId}]: ${chunk.component} (${chunk.progress}%)`);
    
    // Update connection timestamp
    connectionTimestamps.set(conversationId, Date.now());
    return true;
  } catch (error) {
    console.error(`‚ùå emitCodeChunk failed [${conversationId}]:`, error);
    cleanupConnection(conversationId);
    bufferChunk(conversationId, codeChunk);
    return false;
  }
}

/**
 * Emit a completion event
 */
export function emitCodeComplete(
  conversationId: string,
  fullCode: string
): boolean {
  if (!isControllerHealthy(conversationId)) {
    return false;
  }

  const controller = globalCodeEmitters.get(conversationId)!;

  try {
    const completeMsg = {
      id: `complete-${Date.now()}`,
      type: 'complete',
      code: fullCode,
      timestamp: new Date().toISOString(),
    };
    const data = `data: ${JSON.stringify(completeMsg)}\n\n`;
    controller.enqueue(encoder.encode(data));
    console.log(`üì§ emitCodeComplete [${conversationId}]: Code generation finished`);
    return true;
  } catch (error) {
    console.error(`‚ùå emitCodeComplete failed [${conversationId}]:`, error);
    return false;
  }
}

/**
 * Emit an error event
 */
export function emitCodeError(
  conversationId: string,
  error: string
): boolean {
  if (!isControllerHealthy(conversationId)) {
    return false;
  }

  const controller = globalCodeEmitters.get(conversationId)!;

  try {
    const errorMsg = {
      id: `error-${Date.now()}`,
      type: 'error',
      error,
      timestamp: new Date().toISOString(),
    };
    const data = `data: ${JSON.stringify(errorMsg)}\n\n`;
    controller.enqueue(encoder.encode(data));
    console.log(`üì§ emitCodeError [${conversationId}]: ${error}`);
    return true;
  } catch (err) {
    console.error(`‚ùå emitCodeError failed [${conversationId}]:`, err);
    return false;
  }
}

/**
 * Wait for code stream connection to be ready
 */
export async function waitForCodeConnection(conversationId: string, timeoutMs = 3000): Promise<boolean> {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeoutMs) {
    if (isControllerHealthy(conversationId)) {
      return true;
    }
    await new Promise(resolve => setTimeout(resolve, 50));
  }
  
  console.log(`‚ö†Ô∏è Timeout waiting for code stream connection: ${conversationId}`);
  return false;
}
